# Minesweeper

Како тема за проектната задача по визуелно прогамирање ние одбравме да ја имплементираме познатата игра Minesweeper. Имплементацијата е целосно наша и е почната од нула. Играта е наменета за сите возрасти и бара многу размислување, брзина и вежбање со цел да се подобри сопственото рекордно време. 

Правилата се прости: во дадена матрица играчот кликнува на полиња, ако кликне бомба тогаш тој губи, а победува ако ги отвори сите полиња што не се бомби, без притоа да отвори бомба. Полињата што не се бомби можат да имаат вредност од 0 до 8. Оваа вредност означува колку бомби има околу тоа поле. Ако вредноста на едно поле е 0, тогаш тоа поле е празно и ако се кликне на него автоматски се шири на сите осум страни. Бомбите со секоја нова игра се измешани во матрицата, правејќи уникатна партија. Играчот со лев клик на глувчето го отвара полето, со десен клик поставува знаменце со што претпоставува дека таму има бомба, а со уште еден десен клик на полето се поставува прашалник кој означува несигурност за вредноста на полето.

Нашата верзија нуди три степени на тежина: easy, medium и hard. Разликите помеѓу тежините се бројот на полињата во матрицата и бројот на бомби во неа. Лесната тежина се состои од 25 полиња во 5x5 матрица, средната има 100 полиња во 10x10 матрица, и тешката има 225 полиња во 15x15 матрица. Бројот на бомби го определивме да биде 25% од полињата, т.е (int)Math.Round(0.25 * rows * rows). Ако првиот клик во полето резултира во откривање на бомба, бомбата се брише за да нема фрустрирачки игри кои ќе завршат веднаш кога ќе почнат. Полињата се креираат со нитка, за да се избегне непотребно чекање при стартување на играта. 

Апликацијата се состои од две форми, првата ја содржи играта додека втората е помошна форма за почнување на нова игра. Во оваа помошна фома се внесува име и тежина на новата партија. Ако играчот победи и направи рекордно време за победа, неговото име ќе биде испишано во одделена датотека во која се држи статистика (број на партии, број на победени партии, најбрзо време, итн.). Овие информации може да се видат со копчето Stats во менито.

# Документација

###Program.cs
Во функцијата main() се иницијализира нитката oThread која го креира минското поле со функцијата GenerateFields() со цел да се оптимизира визуелизацијата на програмата, а потоа се пушта формата Form1 во која се игра играта. Во GenerateFields() се креира матрица од 15x15 што е всушност големината на матрицата за тешката партија. Фунцкијата setLimits ги брише референците на полињата што се наоѓат надвор од матрицата за играње во случајот кога ќе се одбере лесна или средна тежина, бидејќи тогаш матрицата е помала од стандардната изгенерирана матрица. Сите полиња во матрицата се поврзани во листа за полесен пристап кон нив. Ова е изведено со функцијата connect(). Функцијата resetFields() ги ресетнува стандардните вредности на сите полиња со секоја нова игра. Мините се поставуваат на произволни места со функциите randomNewGame и Shuffle. Ако играчот стисне на бомба, тогаш играта завршува и со uncoverBombs() се покажуваат сите бомби на полето.

###Form1.cs
Оваа форма се иницијализира во конструкторот каде што се иницијализира и тајмерот кој го мери времето на партијата, што се ажурира со timer1_Tick на секои 100 милисекунди (стандардното timer.Inteval време). Со клик на New копчето на менито, се отвара формата Form2. Откако ќе се изгаси оваа форма, Form1 ќе започне нова игра базирана на внесените податоци, но само ако полето за име не е празно.

###Form2.cs
Формата исто како Form1 не дозволува променување на големината на прозорецот со this.MaximizeBox = false. Со копчето Start! се затвора оваа форма за потоа Form1 да ги земе внесените податоци, а Cancel ја затвора формата и го брише името со што Form1 нема да започне нова игра. Копчето Start! нема да дозволи да нема внесено име, како и errorProvider1 што прави валидација на текст полето за име.

###MineField.cs
Оваа класа ја проширува класата PictureBox и е всушност секое поединечно поле во матрицата. Секое поле содржи референци (up, down, left, right) до неговите соседни полиња. Дијагоналните соседи може лесно да се пристапат со помош на овие четири референци, на пример this.up.left за соседот на горниот лев ќош. Функцијата calculate() пресметува колку бомби има околу полето со цел да се прикаже точната бројка, а ако самото поле е бомба тогаш наместо бројка на полето се прикажува бомба. Визуелниот приказ се извршува во функцијата uncover(). Сите слики на броевите, бомбата, прашалникот и знаменцето се ставени во hash табела (Dictionary<String, Image> map) за да не се вчитуваат за секое поле поединечно. Во случај кога се кликнува на поле за кое што ниеден сосед не е бомба, тоа треба рекурзивно да ги отвори сите соседни полиња, како и наредните полиња кои не се бомби. Ова се изведува со функцијата recalculate().

#Изработиле:
#####Боријан Георгиевски
#####Дејан Рајковски
#####Бодан Ѓозински
